#Реализация обработчика событий

Необходимо написать реализацию интерфейса **EventHandler**.

* `1`: События поступают на обработку из разных, никак не синхронизованных между собой, потоков.
* `2`: События должны быть обработаны в том порядке – в котором они поступили в EventHandler.
* `3`: Необходимо реализовать механизм запуска и остановки обработчика.
* `4`: В случае вызова метода **EventHandle.stopHandler()** должен обработать все имеющиеся в очереди события и только после этого завершить работу.
* `5`: Так же необходимо минимизировать процессорные затраты во время простоя обработчика (когда нет новых событий, а старые уже обработаны).
* `-`: При реализации *не использовать* пакет *java.util.concurrent*.

Состояние потока обработчика полностью зависит от (объекта) содержимого списка.

Поэтому на момент остановки работы обработчика, он (обработчик) может находиться либо в состоянии сна либо еще в рабочем состоянии...и в этот момент я пытаюсь прервать его работу - падает Exception.

Первый 'while' работает все всремя жизни побочного потока.

Второй 'while' работает как проверка нужно ли побочному потоку (обработчику) спать.

* `ArrayDeque`: для реализации выталкивающей очереди списка. *Одна из реализаций двухсторонней очереди структуры в которой элементы расположены линейно и связаны каждый с двумя соседями в обе стороны. Т.е. её можно пройти с обоих концов, достать любой элемент за O(n), а первый или последний вставить или удалить за О(1)*.

* `Thread`: в качестве обработчика создается побочный поток - запуск обработчика событий сопровождается созданием нового потока и его запуском
* `синхронизация на добавления событий в очередь`: центральным игроком является компонент очереди событий (список) и поскольку приложение работает в много-поточной среде - внутренняя синхронизация проводится по компоненту очереди
* `обработчик очереди событий`: пока список очереди пуст - побочный поток засыпает ( *wait* ), когда добавляется новое событие - побочный поток пробуждается ( *notify* ) и в цыкле обрабатывает их. Каждый раз новые события добавляются в конец списка а обработанные удаляются из начала списка.
* `остановка обработчика`: меняется флаг состояния *и пробуждается поток*, если список очереди событий пуст - тогда, вместо засыпания, завершается работа потока через выход из этого метода.
