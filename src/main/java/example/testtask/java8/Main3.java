package example.testtask.java8;

import java.util.Arrays;
import java.util.List;

/**
 * Created by Саша on 18.01.2016.
 * ******************************
 * https://github.com/Home-Java8/Solutions/blob/master/src/com/Task2.java
 * https://github.com/Home-Java8/Solutions/blob/master/src/com/Task3.java
 *
 * http://thedifference.ru/chem-otlichaetsya-bit-ot-bajta/
 * http://www.ibm.com/developerworks/ru/library/j-codetoheap/
 * http://frolov-lib.ru/programming/javasamples/vol1/vol1_1/index.html | http://old.ami.lnu.edu.ua/books/prjava/vol1/ch4.html
 * http://habrahabr.ru/post/76481/
 * http://kostin.ws/java/java-types-and-variables.html
 */
public class Main3 {

    public static void main(String[] args) {
        Main3 main = new Main3();
        System.out.println( main.func(5,3) );
        System.out.println( main.fact(3) );

        String str1 = "122333"; //String str1 = "122333444455555122333444455555";
        System.out.println(str1);
        System.out.println(str1.replace("3","33"));
        System.out.println(str1.replaceAll("3", "33"));

        /**
         * идеология реализации такого алгоритма 'перевернуть массив' заключается в том что экономяться ресурсы память и шагов проходов по массиву (немного нагружается процессор)
         * 0. (при условии что это цифровой массив) планируется перебрать только половину массива...
         * 1. суммируем результат зеркальных (относительно центра - левая|правая половина) элементов массива и сохраняем его (результат), например, в элемент массива из левой половины...
         * 2. тогда для элемента массива из правой половины вычисляется разница от суммы (левого|правого элементов) минус значение элемента массива из правой половины...
         * 3. а для элемента массива из левой половины вычисляется разница от суммы (левого|правого элементов) минус значение элемента массива из, тоже, правой половины (поскольку здесь значение уже изменилось...)
         */
        int[] iArr1 = {1,2,3,4,5,6,7,8,9,0};
//        for (int i : iArr1){
//            System.out.print(i);
//        }
//        System.out.println();
        for (int i=0; i<(iArr1.length/2); i++){
            iArr1[i]                += iArr1[iArr1.length-i-1];
            iArr1[iArr1.length-i-1] = iArr1[i] - iArr1[iArr1.length-i-1];
            iArr1[i]                = iArr1[i] - iArr1[iArr1.length-i-1];
        }
        for (int i:iArr1) System.out.print(i);

        System.out.println();
        List alist = Arrays.asList(iArr1);
//        for (Object i : alist) System.out.print((Integer)i); // ClassCastException (неправильное приведения типов)

        /**
         * Базовые типы в Java (их 8):
         * ----------------------- boolean=[~4-байта | переменные этого типа могут быть по-разному упакованы jvm]
         * - (цыферки) ----------- byte=[1 байт], char=[2 байта], short=[2 байта], int=[4 байта], long=[8 байт]
         * - (нецелые цыферки) --- float=[4 байта], double=[8 байт]
         * Примеры литералов:
         * false // литерал типа boolean
         * 'a'  // литерал типа char — печатный символ, задаётся в одинарных кавычках
         * '\t' // литерал типа char — специальный символ, не отображается в виде какого-либо значка на экране, но управляет выводом или его форматированием, например, данный символ добавляет в вывод символ табуляции (отступа)
         * 2  // литерал типа int
         * 2L // литерал типа long, можно использовать строчную букву l
         * 2F // литерал типа float, можно использовать строчную букву f
         * 2D // литерал типа double, можно использовать строчную букву d
         *
         * Ссылочная переменная (Объекты):
         * ++ у каждого объекта есть заголовок = [8(12) байт, для 32-х и 64-х разрядных системах]
         * ++ На каждый объект хранится ссылка = [4(8) байт, для 32-х и 64-х разрядных системах]
         * -- размеры экземпляров классов могут отличатся от одной JVM к другой
         * -- В 32-х разрядных системах размер указателя на ячейку памяти занимает 32 бита
         * -- В 64-х разрядных системах размер указателя на ячейку памяти занимает 64 бита
         * - Integer=[16 байт]
         * - String=[24 байта]
         * - Array=[16(24) байт]
         * - ArrayList=[80(144) байт]
         * - LinkedList=[24(40) байт]
         * - TreeSet=[64(104) байт]
         * - HashSet=[136(240) байт]
         * - LinkedHashSet=[176(320) байт]
         * - IdentityHashMap=[344(656) байт]
         * - ConcurrentHashMap=[1306=(2428) байт]
         */
        byte bValNeg = -128;
        byte bValPos = -127;
        char cVal = 0;
        char cValPos = 65535;
        short sValNeg = -32768;
        short sValPos = 32767;
        int iValNeg = -2147483648;
        int iValPos = 2147483647;
        long lValNeg = -9223372036854775808l;
        long lValPos = 9223372036854775807l;
        // boolean                                                      // (~4-байта)
        System.out.println("byte: " + bValNeg + "; " + bValPos + ";");  // (1-байт)
        System.out.println("char: " + cVal + "; " + cValPos + ";");     // (2-байта: используется для хранения символов в кодировке UNICODE)
        System.out.println("short: " + sValNeg + "; " + sValPos + ";"); // (2-байта)
        System.out.println("int: " + iValNeg + "; " + iValPos + ";");   // (4-байта)
        System.out.println("long: " + lValNeg + "; " + lValPos + ";");  // (8-байт)
        // float                                                        // (4-байта)
        // double                                                       // (8-байт)
        /**
         * Бит [Кбит] - может принимать значение 0 или 1
         *              (это минимальная единица измерения количества информации) в двоичной системе счисления бит равен одному разряду
         *              то есть в общем представлении 'бит' это единица физического элемента (тригер - состояние логического устройства)
         * Байт [Кб] – может принимать значение от 0 до 256
         *             единица хранения цифровой информации (представляющая собой совокупность битов, в одном байте – 8 бит) которые система может обрабатывать одновременно
         *             то есть в общем представлении 'байт' это единица логического элемента (символ - машинное слово)
         * -- вычислительная техника бывает 8,16,32,64 разрядной И в зависимости от разрядности размера хранения информации (в битах) которая будет обрабатываться одновременно тоже будет разная...
         */
    }

    public int func(int tchislo, int step){
        return 1<step ? tchislo*func(tchislo,(step-1)) : tchislo;
    }

    /**
     * Как работает рекурсивная функция (функция вызывает саму-себя):
     * 1. (первое) в 'стеке' выстраивается свяазанная цепочка вызовов (рекурсивной) функции...
     *    особенность внутри такой цепочки в том, что для каждой следующей вызываямой функции передается уникальный параметр...
     * 2. выход из такого рекурсивного цыкла происходит через выброс 'return'
     *    при этом каждая последняя функция возвращает значение - такое значение можно суммировать...в блоке предшествующей функции
     * 3. условием для выхода из цыкла рекурсии можно управлять через передаваемый параметр И проверять его (условие) в теле функции...
     *    чтобы такое условие выполнялось нужно в передаваемом параметре, для функции, менять значение
     *
     * @param n
     * @return
     */
    public int fact(int n){
        if (n == 0) return 1;
        if (n == 1) return 5;
        return 5 + fact(n-1);
    }
//    public int fact(int n){
////        int result;
////        if (n == 1) result = 1; // StackOverflowError
////        result = n + fact(n-1);
//        if (n == 0) return 1;
//        if (n == 1) return 5;
////        result = 5 + fact(n-1);
////        return result;
//        return 5 + fact(n-1);
//    }
}
