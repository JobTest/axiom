#[1] Реализация обработчика событий

Необходимо написать реализацию интерфейса **EventHandler**.

* `1`: События поступают на обработку из разных, никак не синхронизованных между собой, потоков.
* `2`: События должны быть обработаны в том порядке – в котором они поступили в EventHandler.
* `3`: Необходимо реализовать механизм запуска и остановки обработчика.
* `4`: В случае вызова метода **EventHandle.stopHandler()** должен обработать все имеющиеся в очереди события и только после этого завершить работу.
* `5`: Так же необходимо минимизировать процессорные затраты во время простоя обработчика (когда нет новых событий, а старые уже обработаны).
* `-`: При реализации *не использовать* пакет *java.util.concurrent*.

Состояние потока обработчика полностью зависит от (объекта) содержимого списка
Поэтому на момент остановки работы обработчика, он (обработчик) может находиться либо в состоянии сна либо еще в рабочем состоянии...и в этот момент я пытаюсь прервать его работу...и падает Exception
первый 'while' работает все всремя жизни побочного потока
второй 'while' работает как проверка нужно ли побочному потоку (обработчику) спать

* `LinkedList`: хранит елементы в списке в том порядке в котором они были добавлены
* `Thread`: в качестве обработчика создается побочный поток - запуск обработчика событий сопровождается созданием нового потока и его запуском
* `синхронизация на добавления событий в очередь`: центральным игроком является компонент очереди событий (список) и поскольку приложение работает в много-поточной среде - внутреннюю синхронизацию буду проводить по компоненту очереди
* `обработчик очереди событий`: пока список очереди пуст - побочный поток засыпает (wait), когда добавляется новое событие - побочный поток пробуждается (notify) и в цыкле обрабатывает их. Каждый раз новые события добавляются в кноцец списка а обработанные удаляются из начала списка
* `остановка обработчика`: меняется флаг состояния (и пробуждается поток), если список очереди событий пуст - тогда (вместо засыпания) завершается робота потока (через выход из этого метода)


* `Поправка`: будет правильным применить **Queue** *( **PriorityQueue** )* для реализации выталкивающей очереди списка...

#[2] Задача о городах и дорогах

Необходимо реализовать интерфейс для получения следующих данных:

* `1`: Добавить новый город (город определяется по имени и координатам), может быть два города с одним именем, но разными координатами.
* `2`: Нужно уметь добавлять дороги:
* `2.1` Дорога имеет имя.
* `2.2` Дорога всегда при создании имеет два города, между которыми она проведена (не может быть дорога без городов).
* `2.3` Дорога может соединять только два разных города, дорога не может проходить через город и соединять третий город (при таком примере, будет две разных дороги).
* `3`: Надо уметь получить по городу дороги, которые из этого города ведут.
* `4`: Надо уметь удалять дороги и города.


* `Поправка`: в этой задаче применяются разные способы для поиска (дорог, городов...). Но между ними есть одна особенность:
1. У каждой дороги есть координаты которые всегда имеют строгий порядок (X,Y)
2. Каждая дорога соединяет два разных города. Но здесь нет строгого порядка в каком должны быть перечислены города (это может быть: либо City1-City2 либо наоборот City2-City1...)

> Поэтому:

* для быстрого поиска элементов можно применить **HashMap-у** - это при условии что используется только строгий порядок перечисления параметров...
* если же порядок перечисления параметров НЕстрогий - тогда применяем **алгоритм Дейкстры** (для нахождения кротшайших путей в графе)
* сперва, предварительно-же нужно построить список (дорог, городов...) с помощью **ArrayList**, а потом уже отдельно реализовывать логику для поиска элементов в списке (чтобы таким способом отделить наш список элеменитов от реализации логики...инначе при  каждом изменении условия в логике нужно будет все переписывать)
* (применения сортировок здесь НЕуместно, потому-что идеологически динамическую сортировку лучше можно применять для небольших списков для формирования списка уже на выходе, а статическая сортировка здесь неиспользуется...)
