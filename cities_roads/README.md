#Задача о городах и дорогах

Необходимо реализовать интерфейс для получения следующих данных:

* `1`: Добавить новый город (город определяется по имени и координатам), может быть два города с одним именем, но разными координатами.
* `2`: Нужно уметь добавлять дороги:
* `2.1` Дорога имеет имя.
* `2.2` Дорога всегда при создании имеет два города, между которыми она проведена (не может быть дорога без городов).
* `2.3` Дорога может соединять только два разных города, дорога не может проходить через город и соединять третий город (при таком примере, будет две разных дороги).
* `3`: Надо уметь получить по городу дороги, которые из этого города ведут.
* `4`: Надо уметь удалять дороги и города.


Для гибкости и прозрачности при построении модульной архитектуры:

* вся логика по реализации приложения помещена в абстрактный класс *ServiceSome* (это позволяет менять реализацию локально в коде, без сопровождения глобальных изменений)
* условия которые выполняют проверку описываются в отдельных классах (которые реализуют интерфейсы *Items* , *Service*)
* Здесь методы интерфейса намерено разнесены по *Items* и *Service* . Это сделано по той причине чтобы получить возможность максимально продуктивно реализовать операции добавления новых элементов в список и операцию поиска элементов, при условии что реализация обеих операций являются независимыми друг-от-друга.
* для релизации быстрого поиска элементов можно применить *хеш-карту* . Ключевыми объектами согласно логике поиска являются *KeyCity* и *KeyRoad* .
* для релизации проверки условия что дорога проходит только между двумя городами можно применить **алгоритм Дейкстры**
* Здесь чтобы придать коду гибкости и прозрачности - классы ( *KeyCity* , *KeyRoad* и *Dijkstra* ) вынесены на уровне пакета с применением дефолтных методов (чтобы запретить несанкционированный доступ стороним классам за пределами пакета).


* Для реализации алгоритма поиска элементов применяются два разных списка ( из пакета *java.util.concurrent* ):
> 1. **ConcurrentLinkedQueue** позволяет синхронно и очень быстро добавлять / удалять элементы в списке
> 2. **ConcurrentHashMap** позволяет очень быстро и синхронно работать с *хеш-таблицами*

> Связь элементов между этими разными списками выполняется по ссылке, то есть, имея ссылку на объект - доступ к методам этого объекта можно получить мгновенно.
