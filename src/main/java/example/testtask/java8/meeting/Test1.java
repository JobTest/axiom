package example.testtask.java8.meeting;

/**
 * Created by Саша on 19.01.2016
 * *****************************
 * Наследование - это расширение функциональных возможностей в классе наследнике за счет родительского класса
 * Инкапсуляция - это скрытие сложного механизма вызовов множества разных методов класса через общий метод с открытым доступом
 * Полиморфизм - это изменение поведения методов в классе наследнике через переопределение
 * * * * * * * * * * * * * * * *
 * {@link http://cybern.ru/java-polymorphism.html}
 * {@link http://www.javable.com/tutorials/fesunov/lesson8/#%3F%3F%3F%3F%3F%3F%3F%3F%3F%3F%3F}
 ** {@link http://crypto.pp.ua/2010/06/pereopredelenie-metodov-i-polimorfizm-java/}
 * Переопределение методов и полиморфизм java:
 * Способность Java делать выбор метода, исходя из типа объекта во время выполнения, называется поздним связыванием.
 * При вызове метода его поиск происходит сначала в данном классе, затем в суперклассе, пока метод не будет найден или не достигнут Object – суперкласс для всех классов.
 ** {@link http://www.ccfit.nsu.ru/~deviv/courses/oop/tij2nd/Chapter07.html}
 * Забывание типа объекта:
 * Почему кто-то должен намеренно забыть тип объекта?
 * А это происходит, когда, Вы производите приведение к базовому типу
 ** {@link http://java-course.ru/begin/polymorphism/}
 * Полиморфизмом назвается возможность работать с несколькими типами так, как будто это один и тот же тип и в то же время поведение каждого типа будет уникальным в зависимости от его реализации.
 *
 * Reflection — спросить у объекта его класс и у класса спросить его имя.
 */
public class Test1 {
    public static void main(String[] args) {
        Parent p = new Chield();
        p.test1(); // - метод с дефолтной областью видимости будет доступен и для классов наследников только в одном пакете
                   // А здесь происходит очень интересная вещь:
                   // - с одной стороны как-бы доступны только методы объявленного типа - родительского класса (несмотря что екземпляр класса имеет является - классом наследником)
                   // - но с другой стороны полиморфизм штука хитрая И точно такой-же метод будет искать сначала в классе наследнике (вопреки законам интерфейса)
//        p.test2(); // поскольку в родительском классе область видимости для этого метода запрещает доступ в классе наследнике, поэтому:
                     // - согласно закону интерфейса такого метода несуществует и поэтому здесь будет ошибка компиляции...на момент вызова
        p.test3(); // согласно законам JAVA можно расширять область видимости в классах наследниках НО сужать область видимости в классах наследниках нельзя
                   // - поэтому здесь будет ошибка компиляции...на момент переопределения

//        Chield c = new Parent(); // в обратную сторону присваивание НЕ работает
        Parent p1 = new Parent();
        Chield c1 = new Chield();
        p1 = c1;         // на момент присвоения - повышать тип можна! (JAVA автоматически делает приведение типов в сторону повышения)
        c1 = (Chield)p1; // но - понижать тип нельзя! (для этого нужно явно сделать приведения типов, JAVA этого неделает)
    }
}


class Parent {
    void test1(){
        System.out.println("Parent test-1");
    }
    private void test2(){
        System.out.println("Parent test-2");
    }
    public void test3(){
        System.out.println("Parent test-3");
    }
}

class Chield extends Parent {
    public void test1(){
        System.out.println("Chield test-1");
    }
    public void test2(){
        System.out.println("Chield test-2");
    }
//    protected void test3(){
//        System.out.println("Chield test-3");
//    }
}