
# Хеш-карты

Первое что нужно знать это три основных случая при работе с хеш-картами:

1. Методы: hashCode() и equals() - обязательно должны быть переопределены:
   - Если НЕпереопределить хотя-бы один из методов hashCode() и equals()
   - или есои плохо определить метод equals()
   - или если в ходе работы измениться ключевое поле которое участвует в формировании метода hashCode()
   = тогда в этих случаях потеряется ссылка на элемент.
   = и в результате будет расти расходуемые ресурсы памяти НО ссылки на элементы будут утеряны (несмотря на то что итератором все элементы можно найти в списке...)
2. Если формирование метода hashCode() будет плохо определено:
   - (будут частые колизии, НО механизм поиска элементов по ссылкам в целом работать будет)
   = и в результате скорость поиска элементов по ссылке будет расти
   = даже если метод hashCode() будет возвращать одно-постоянное число (механизм поиска элементов по ссылкам в целом тоже работать будет НО) эфективность работы поиска элементов будет плохая-минимальная (приравниваться к LinkedList)
3. Если методы: hashCode() и equals() будут хорошо переопределены:
   = в результате получим максимально эфективный механизм поиска элементов
   = и минимум затрат на используемые ресурсы памяти

Вообще-то хеш-карты предназначались как инструмент для очень быстрого и максимально-эфективного поиска элементов в списке!


# Простые списки

1. LinkedList
   - такой механизм испольуется обычно для первичного построения списка (при условии что изначально ничего об параметрах первичного списка неизвестно)
   - НО уже операции поиска элементов в таком списке - являются НЕэфективными и очень медленными
   = в результате это позволяет за равно-одинаковое время (быстро) добавлять элементы в любое место списка
   = еще такой список эффективно можно использовать для объединения нескольких разных списков в (общий) один-большой список
2. ArrayList
   - такой механизм испольуется обычно для первичного построения списка (при условии что изначально параметры первичного списка известны)
   - НО уже перестраивать такой сформированный список - является НЕэфективным и очень медленным
   = в результате это позволяет за равно-одинаковое время (быстро) добавлять элементы только в конец списка И выполнять доступ к любому элементу за равно-одинаковое время


# Сортирующие и самосортирующие структуры

1. TreeMap, TreeSet:
   - Важно чтобы элементы которые используются в таком списке имели определение метода: compareTo() И являлись наследником Comparable или Comparator
     (метод compareTo() - является условием для алгоритма сортировки...)
   - если метод compareTo() НЕопределен (это приведет к ошибке на рантайм-уровне)
   - если метод compareTo() возвращает - '0' (это приведет к потере элементов которые добавляются в такой список)
   - если метод compareTo() возвращает - '1' или '-1' (тогда такой список будет отсортирован в прямом или обратном порядке по истории добавления элементов)
   = Что сортировка правильно работала нужно в методе compareTo() определить собственное условие сортировки
2. Формирование таких сортирующих-списков с большими объемами очень ресурсоемкая по времени операция
   = поэтому формировать такие само-сортирующие-списки есть смысл только в том случае когда такой список является ДОЛГОЖИВУЧИМ И часто используется для поиска элементов по разным критериям...

Основная цель использования такого списка служит для представления (небольших) данных-результатов, от выполнения предварительных операций, в удобной форме для пользователя!