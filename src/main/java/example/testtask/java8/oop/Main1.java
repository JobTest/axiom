package example.testtask.java8.oop;

/**
 * ***********************************
 * > Наследование - это расширение функциональных возможностей в классе-наследнике за счет родительского-класса
 * > Инкапсуляция - это скрытие сложной логики реализации в одной функции класса
 * > Полиморфизм - это изменение поведения функции в классах-наследниках
 *
 * > Разные функции - у которых разные: название и тип и параметры - подчиняются правилам наследования и инкапсуляции
 * > Одинаковые функции - у которых совпадают: название и тип и параметры - подчиняются правилам полиморфизма:
 * >>                     переопределение - это изменение реализации тела функции которая имеет одинаковые названия и типы и параметры
 *                                          переопределение работает только для классов наследников (в одном классе НЕможет быть более одной такой функции)
 *                                          переопределеная функция - приравнивается как одна-единственная функция...
 * >>                     перегрузка - это изменение реализации тела функции которая имеет одинаковые названия НО разные параметры (можно и разные типы)
 *                                     в одном классе может быть много перегруженных функций
 *                                     перегруженная функция - приравнивается как другая (разная) функция...
 *
 * > При создании объекта задействованы операции:
 * >> Версия реализации - объект собирает в себе все методы своего класса И методы классов всех своих родителей
 *                        это первый этап, на этом этапе:
 *                        - находяться и собираются все разные методы ТАКЖЕ это касается и перегруженных методов
 *                        - находяться переопределенные методы И все родительские методы перекрываются последним методом класса-наследника
 * >> Тип интерфейса - ограничивает область видимости для методов
 *                        это второй этап, на этом этапе:
 *                        - отсекаются все те методы которые за пределами области видимости
 *                        - (для разных методов) каждый метод принадлежит конкретному типу интерфеса
 *                        - (для одинаковых методов) все методы родительских классов перекрываются последним методом класса-наследника И он является единственным
 * >> Приведение типа - (после того как компилятор разпределил доступные методы) компилятор выполняет поиск-совпадения для вызываемых методов
 *                        это третий этап, на этом этапе:
 *                        - по идентичному названию и тиу и параметрам: определяется к какому классу принадлежит метод (найденый такой метод в конкретном классе и будет задействован)
 *                        - если такого метода нет, тогда для методу из типа интерфейсного класса выполняется приведение типа параметров: если тип параметра является наследников - тогда такой метод в классе типа интерфейса будет задействован (инначе получим ошибку компиляции - если это любой родительский тип, например: 'Object')
 *
 * > Компилятор выполняет поиск начиная с (низов) последнего класса-наследника и двигается (на вершину) в сторону родительского-класса
 * >> 1. формируется объект версии реализации (который собирает все разные методы и перекрываем одинаковые методы)
 * >> 2. отсекает типом интерфейса область видимости для доступных методов
 * >> 3. приведение типа выполняет поиск-выбор реализации методов в нужном классе
 * >> + эти действия выполняются при условии что будет использовано расширяющее приведение типа (то есть, объект/ссылка типа класса-наследника приводится к родительскому типу)
 *    + расширяющее приведение типа выполняется автоматически компилятором (НЕявно)
 * >> - в случае выполнения сужающего приведения типа - нужно выполнять явно (компилятор этого неделает)
 *    - проблема сужающего приведения типа в том что (уже после комптляции) выбрасывается исключение в RuntimeException (ClassCactException)
 *    - сужающее приведения типа используется когда ожидаются разные типы объектов в процессе выполнения И используются метоты родительского-класса
 *
 * > Существует три способа приведения типов в Java:
 *   1. Обычный (нормальный) - когда тип интерфейса совпадает с версией реализации
 *   2. (По умолчания НЕявное приведение) расширяющее приведение - когда тип приводимого объекта выше типа ожидающей переменной
 *   3. (Явное приведение) сужающее приведение - когда тип приводимого объекта ниже типа ожидающей переменной
 */
public class Main1 {

    public static void main(String[] args) {
        System.out.println("--------------------------[1]");
        A a1 = new A();
        B b1 = new B();
        C c1 = new C();

        a1.func1();
        b1.func1();
        c1.func1();
        a1.func2(new X());
        b1.func2(new X());
        c1.func2(new X());
        a1.func3(new A());
        b1.func3(new B());
        c1.func3(new C());

        System.out.println("--------------------------[2]");
        A a2 = new C();
        B b2 = new C();
        C c2 = new C();

        a2.func1();
        b2.func1();
        c2.func1();
        a2.func2(new X());
        b2.func2(new X());
        c2.func2(new X());
        a2.func3(new A());
        b2.func3(new B());
        c2.func3(new C());

        System.out.println("--------------------------[3]");
        A a3 = new C();
        B b3 = new C();
        C c3 = new C();

//        a3.func3(new X()); // Ошибка компиляции
        a3.func3(new A());
        a3.func3(new B());
        a3.func3(new C());
        a3.func3(new D());

//        b3.func3(new X()); // Ошибка компиляции
        b3.func3(new A());
        b3.func3(new B());
        b3.func3(new C());
        b3.func3(new D());

//        c3.func3(new X()); // Ошибка компиляции
        c3.func3(new A());
        c3.func3(new B());
        c3.func3(new C());
        c3.func3(new D());

        System.out.println("--------------------------[4]");
        AA aa = new AA();
        aa.func();
        aa.func(1);
        aa.func('a');

        aa.my();
        aa.my(1);
    }

}


class X {}
class A extends X {
    public void func1(){
        System.out.println("A func1");
    }
    public void func2(X x){
        System.out.println("A func2");
    }
    public void func3(A a){
        System.out.println("A func3");
    }
}
class B extends A {
    public void func1(){
        System.out.println("B func1");
    }
    public void func2(X x){
        System.out.println("B func2");
    }
    public void func3(B b){
        System.out.println("B func3");
    }
}
class C extends B {
    public void func1(){
        System.out.println("C func1");
    }
    public void func2(X x){
        System.out.println("C func2");
    }
    public void func3(C c){
        System.out.println("C func3");
    }
}
class D extends C {}


class AA {
    int func(){
        System.out.println("AA int");
        return 1;
    }
//    char func(){
//        System.out.println("AA char");
//        return 2;
//    }
    int func(int i){
        System.out.println("AA int int");
        return i;
    }
    char func(char c){
        System.out.println("AA char char");
        return c;
    }

    void my(int i){
        System.out.println("void my int");
    }
    int my(){
        System.out.println("int my");
        return 0;
    }
}


interface AAA {
    void func();
    int func1();
}
interface BBB {
    void func();
    int func2();
}
interface CCC extends BBB {
//interface CCC {
    void func();
    int func3();
}
class DDD implements BBB,CCC,AAA {

    @Override
    public void func() {

    }

    @Override
    public int func1() {
        return 0;
    }

    @Override
    public int func2() {
        return 0;
    }

    @Override
    public int func3() {
        return 0;
    }
}


class AAAA {
    public void func() {
        System.out.println("AAAA func");
    }
}
class BBBB {
    public void func() {
        System.out.println("BBBB func");
    }
}
class CCCC extends AAAA implements AAA {
    @Override
    public int func1() {
        return 0;
    }
}
